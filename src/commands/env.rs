use anyhow::Result;
use std::env;

use crate::utils::{
    config::load_config,
    envcheck::{doctor_path_issues, parse_dotenv, validate_env_schema},
};

pub async fn doctor() -> Result<()> {
    let root = env::current_dir()?;
    let mut issues = doctor_path_issues();

    if root.join(".devflow.yaml").exists() {
        let cfg = load_config(&root)?;
        let vars = parse_dotenv(&root)?;
        for i in validate_env_schema(&cfg.env, &vars) {
            issues.push(format!("env {}: {}", i.key, i.reason));
        }
    }

    if issues.is_empty() {
        println!("env doctor: healthy");
    } else {
        println!("env doctor: {} issue(s)", issues.len());
        for issue in issues {
            println!(" - {}", issue);
        }
    }
    Ok(())
}

pub async fn fix() -> Result<()> {
    let root = env::current_dir()?;
    if !root.join(".env").exists() {
        std::fs::write(root.join(".env"), "# generated by devflow env fix\n")?;
        println!("created .env");
    } else {
        println!(".env already exists; no changes");
    }
    Ok(())
}

pub async fn diff() -> Result<()> {
    let root = env::current_dir()?;
    let current = parse_dotenv(&root)?;
    let snapshot_path = root.join(".devflow/env_snapshot.json");

    if !snapshot_path.exists() {
        let content = serde_json::to_string_pretty(&current)?;
        std::fs::create_dir_all(root.join(".devflow"))?;
        std::fs::write(snapshot_path, content)?;
        println!("saved first env snapshot");
        return Ok(());
    }

    let previous = std::fs::read_to_string(&snapshot_path)?;
    let old: std::collections::HashMap<String, String> = serde_json::from_str(&previous)?;

    for (k, v) in &current {
        match old.get(k) {
            None => println!("added: {}", k),
            Some(oldv) if oldv != v => println!("changed: {}", k),
            _ => {}
        }
    }
    for k in old.keys() {
        if !current.contains_key(k) {
            println!("removed: {}", k);
        }
    }

    Ok(())
}
